each class has its metaclass (Smalltalk-style)

Classes defined in C code are described by Descriptor structure that it
converted into materialized classes during module intialization. Before
the first call to LT_init() these are accumulated in linked list on C
malloc heap and batch initialized during LT_init(), intialization is
no-op for already initialized classes and follows the inheritance
dependencies (this contains a bit of wasted effort by revisiting already 
initialized classes, but there is no other way to do it).

MyClass
 .type = MyClass class
 .superclasses = [A, B]
 .mro = [A, B, ..., Object]

MyClass class
  .type = Metaclass
  .superclasses = [A class, B class]
  .mro = [A class, B class, ..., Class, Behavior, Object]

Objects in superclasses and mro slots are VM-side heap instances of 
ImmutableList in contrast to NULL-terminated arrays in class descriptor.

Method dispatch follows the MRO of the original receiver.
=> MRO is the hidden context of methods invoked by message dispatch, 
   super-send uses (cdr MRO)

Each class has list of methods and slots. Slots are publicly accessible
and have type. Slot type determines the actual in-memory layout of the value.

TBD:
- does it make sense to track list of sub-classes?

Multiple inheritance:
- classes that do not contain native slots can form arbitrary DAG
- when inheriting from class with native slots there can be only one such
  class

when intializing class with multiple superclasses the superclasses slots
are unified and new instance memory layout is created by repacking the 
slots. Native slots cannot be moved. Algorithm is thus two-pass:
- gather all native slots from inheritance hierarchy and check for conflicts
- append all non-native slots with suitable alignment, slots with same name
  get coalesced
The algorithm should try to preserve the ordering as much as possible.

=> there cannot be fixed accessors for non-native slots, the performance
   loss should be offset by in-line caching of slot accesses

